<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://hotarubiemu.github.io/style.css">
    <link rel="stylesheet" href="https://hotarubiemu.github.io/color/pink.css">

        <link rel="stylesheet" href="https://hotarubiemu.github.io/color/background_dark.css">
    
    <link rel="stylesheet" href="https://hotarubiemu.github.io/font-hack.css">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://hotarubiemu.github.io/" style="text-decoration: none;">
                    <div class="logo">
                      
                            Hotarubi
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://hotarubiemu.github.io/">blog</a></li>
            
                <li><a href="https://hotarubiemu.github.io//tags">tags</a></li>
            
                <li><a href="https://github.com/raSTARgfx" target="_blank" rel="noopener noreferrer">github</a></li>
            
                <li><a href="https://hotarubiemu.github.io//pages/errata">errata</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://hotarubiemu.github.io/using-driver-information-as-a-lesson-in-vulkan-structure-chains/">Using Driver Information As A Lesson In Vulkan Structure Chains</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2022-10-15
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://hotarubiemu.github.io/tags/c/">#c++</a>&nbsp;
                <a class="post-tag" href="https://hotarubiemu.github.io/tags/vulkan/">#vulkan</a></span>
    

        
        <div class="post-content">
            <p>I was working on Hotarubi's driver detection today when it hit me that I don't think I've ever seen a nice and simple explanation of what <code>pNext</code> and <code>sType</code> are in the Vulkan API. Sure, <a href="https://github.com/KhronosGroup/Vulkan-Guide/blob/master/chapters/pnext_and_stype.adoc">it's documented very well by Khronos themselves</a> but there isn't much in the way of examples and the examples that do exist can be a little hard to find and interpret for the first time Vulkaneer. So I just want to provide a quick overview using a very simple real-word example.</p>
<blockquote>
<p>I'll be using Vulkan 1.3 for this example but all of the structures I'll be using are also available for earlier forms of the API as extensions. You will, however, need to query support for them and handle any driver's lack of support accordingly. The implementation details of that are outside the scope of this article.</p>
</blockquote>
<p>Let's consider the following chain of Vulkan structures:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties2.html</span><span style="color:#65737e;">
</span><span>VkPhysicalDeviceProperties2 device_props =</span><span>
</span><span>{</span><span>
</span><span>  </span><span style="color:#65737e;">// ..</span><span style="color:#65737e;">
</span><span>};</span><span>
</span><span>
</span><span style="color:#65737e;">// https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIDPropertiesKHR.html</span><span style="color:#65737e;">
</span><span>VkPhysicalDeviceIDProperties id_props =</span><span>
</span><span>{</span><span>
</span><span>  </span><span style="color:#65737e;">// ..</span><span style="color:#65737e;">
</span><span>};</span><span>
</span><span>
</span><span style="color:#65737e;">// https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDriverProperties.html</span><span style="color:#65737e;">
</span><span>VkPhysicalDeviceDriverProperties driver_props =</span><span>
</span><span>{</span><span>
</span><span>  </span><span style="color:#65737e;">// ..</span><span style="color:#65737e;">
</span><span>};</span><span>
</span></code></pre>
<p>Our goal is to call <code>vkGetPhysicalDeviceProperties2</code> with a pointer to <code>VkPhysicalDeviceProperties2</code> . So our top level structure will be <code>device_props</code>. The order of the other two structures, however, is entirely up to you. So long as they properly set the <code>pNext</code> and <code>sType</code> variables, it will work as expected.</p>
<p>Essentially, the driver is going to cast the <code>pNext</code> variable to <code>VkBaseOutStructure*</code> and then check the <code>sType</code> variable for a structure type it supports for this function call (it will ignore any other structure types):</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">typedef struct</span><span> VkBaseOutStructure {</span><span>
</span><span>    VkStructureType               </span><span style="color:#bf616a;">sType</span><span>;</span><span>
</span><span>    </span><span style="color:#b48ead;">struct</span><span> VkBaseOutStructure*    pNext;</span><span>
</span><span>} VkBaseOutStructure;</span><span>
</span></code></pre>
<p>Then it will cast it to the original structure type based on the information in <code>sType</code> and fill it in accordingly. Finally, it will do the same for that structure's <code>pNext</code> variable repeating those steps until it reaches a <code>pNext</code> which is <code>VK_NULL_HANDLE</code>.</p>
<p>If this sounds like CS 101, that's because it's basically a singly linked-list with extra steps.</p>
<p><img src="/linked-list-extra-steps.jpg" alt="" /></p>
<p>This is also the reason that you need to boilerplate all your structures with an <code>sType</code>. Vulkan is a C API and as such it cannot know the actual type of the structure from a void pointer alone. It therefore needs the additional <code>sType</code> variable to know what type of structure it is working with and whether the driver supports that structure for a given function call.</p>
<p>The most obvious thing to do here is this:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>VkPhysicalDeviceProperties2 device_props = {};</span><span>
</span><span>device_props.</span><span style="color:#bf616a;">sType </span><span>= VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;</span><span>
</span><span>
</span><span>VkPhysicalDeviceIDProperties id_props = {};</span><span>
</span><span>id_props.</span><span style="color:#bf616a;">sType </span><span>= VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;</span><span>
</span><span>
</span><span>VkPhysicalDeviceDriverProperties driver_props = {};</span><span>
</span><span>driver_props.</span><span style="color:#bf616a;">sType </span><span>= VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;</span><span>
</span><span>
</span><span>device_props.</span><span style="color:#bf616a;">pNext </span><span>= reinterpret_cast&lt;</span><span style="color:#b48ead;">void</span><span>*&gt;(&amp;id_props);</span><span>
</span><span>id_props.</span><span style="color:#bf616a;">pNext </span><span>= reinterpret_cast&lt;</span><span style="color:#b48ead;">void</span><span>*&gt;(&amp;driver_props);</span><span>
</span><span style="color:#65737e;">// driver_props.pNext = VK_NULL_HANDLE; // implied by = {}</span><span style="color:#65737e;">
</span></code></pre>
<p>We can also go this route:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>VkPhysicalDeviceIDProperties id_props =</span><span>
</span><span>{</span><span>
</span><span>  .</span><span style="color:#bf616a;">sType </span><span>= VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,</span><span>
</span><span>  .</span><span style="color:#bf616a;">pNext </span><span>= VK_NULL_HANDLE,</span><span>
</span><span>};</span><span>
</span><span>
</span><span>VkPhysicalDeviceDriverProperties driver_props =</span><span>
</span><span>{</span><span>
</span><span>  .</span><span style="color:#bf616a;">sType </span><span>= VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,</span><span>
</span><span>  .</span><span style="color:#bf616a;">pNext </span><span>= reinterpret_cast&lt;</span><span style="color:#b48ead;">void</span><span>*&gt;(&amp;id_props),</span><span>
</span><span>};</span><span>
</span><span>
</span><span>VkPhysicalDeviceProperties2 device_props =</span><span>
</span><span>{</span><span>
</span><span>  .</span><span style="color:#bf616a;">sType </span><span>= VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,</span><span>
</span><span>  .</span><span style="color:#bf616a;">pNext </span><span>= reinterpret_cast&lt;</span><span style="color:#b48ead;">void</span><span>*&gt;(&amp;driver_props),</span><span>
</span><span>};</span><span>
</span></code></pre>
<p>And for all intents and purposes, these are both fine solutions.</p>
<p>It does, however, result in some occasionally awkward code. For example, if you want to define your structures without modifying <code>pNext</code> manually after the fact, you need to define them such that they are in the reverse order of their inclusion. Or, alternatively, if you do go setting the various <code>pNext</code> variables after the fact it can get hard to keep track of the chain itself. Both solutions can get even more hairy on earlier versions of the API where you need to query support for these structures before including them in the chain.</p>
<p>Instead, for a little extra runtime cost we can mimic the driver and do something like this:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// the types aren&#39;t important unless you do some static checking</span><span style="color:#65737e;">
</span><span style="color:#65737e;">// feel free to drop the template and use two void*</span><span style="color:#65737e;">
</span><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> B, </span><span style="color:#b48ead;">typename</span><span> T&gt;</span><span>
</span><span style="color:#b48ead;">inline void </span><span style="color:#8fa1b3;">ChainInsert</span><span>(B* </span><span style="color:#bf616a;">base</span><span>, T* </span><span style="color:#bf616a;">item</span><span>)</span><span>
</span><span>{</span><span>
</span><span>  </span><span style="color:#65737e;">// start at the base</span><span style="color:#65737e;">
</span><span>  </span><span style="color:#b48ead;">auto</span><span> head = reinterpret_cast&lt;VkBaseOutStructure*&gt;(base);</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// loop until we reach the end of the chain</span><span style="color:#65737e;">
</span><span>  </span><span style="color:#65737e;">// you might consider runtime checking for a duplicate entry here</span><span style="color:#65737e;">
</span><span>  </span><span style="color:#b48ead;">while </span><span>(head-&gt;</span><span style="color:#bf616a;">pNext </span><span>!= VK_NULL_HANDLE)</span><span>
</span><span>    head = head-&gt;</span><span style="color:#bf616a;">pNext</span><span>; </span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// we broke the loop so pNext is VK_NULL_HANDLE</span><span style="color:#65737e;">
</span><span>  </span><span style="color:#65737e;">// we can insert our item here</span><span style="color:#65737e;">
</span><span>  head-&gt;</span><span style="color:#bf616a;">pNext </span><span>= reinterpret_cast&lt;VkBaseOutStructure*&gt;(item);</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Then it's just a matter of calling <code>ChainInsert</code> with our base and the structures we want to include in the chain:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// first define our structures with pNext as VK_NULL_HANDLE</span><span style="color:#65737e;">
</span><span>VkPhysicalDeviceIDProperties id_props =</span><span>
</span><span>{</span><span>
</span><span>  .</span><span style="color:#bf616a;">sType </span><span>= VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,</span><span>
</span><span>  .</span><span style="color:#bf616a;">pNext </span><span>= VK_NULL_HANDLE,</span><span>
</span><span>};</span><span>
</span><span>
</span><span>VkPhysicalDeviceDriverProperties driver_props =</span><span>
</span><span>{</span><span>
</span><span>  .</span><span style="color:#bf616a;">sType </span><span>= VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,</span><span>
</span><span>  .</span><span style="color:#bf616a;">pNext </span><span>= VK_NULL_HANDLE,</span><span>
</span><span>};</span><span>
</span><span>
</span><span>VkPhysicalDeviceProperties2 device_props =</span><span>
</span><span>{</span><span>
</span><span>  .</span><span style="color:#bf616a;">sType </span><span>= VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,</span><span>
</span><span>  .</span><span style="color:#bf616a;">pNext </span><span>= VK_NULL_HANDLE,</span><span>
</span><span>};</span><span>
</span><span>
</span><span style="color:#65737e;">// using the top level struct as the base</span><span style="color:#65737e;">
</span><span style="color:#bf616a;">ChainInsert</span><span>(&amp;device_props, &amp;id_props);</span><span>
</span><span style="color:#bf616a;">ChainInsert</span><span>(&amp;device_props, &amp;driver_props);</span><span>
</span><span>
</span><span style="color:#65737e;">// using the previous item in the chain as the base</span><span style="color:#65737e;">
</span><span style="color:#65737e;">// if, for exmaple, you know it will be included unconditionally</span><span style="color:#65737e;">
</span><span style="color:#65737e;">// ChainInsert(&amp;device_props, &amp;id_props);</span><span style="color:#65737e;">
</span><span style="color:#65737e;">// ChainInsert(&amp;id_props, &amp;driver_props);</span><span style="color:#65737e;">
</span></code></pre>
<p>Regardless of how you decide to do it, the next step is to call <code>VkPhysicalDeviceProperties2</code> with our base structure and then we can use the other structs in the chain normally:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">const</span><span> VkResult res = </span><span style="color:#bf616a;">VkPhysicalDeviceProperties2</span><span>(physical_device, &amp;device_props);</span><span>
</span><span style="color:#b48ead;">if </span><span>(res != VK_SUCCESS)</span><span>
</span><span>{</span><span>
</span><span>  </span><span style="color:#65737e;">// handle failure</span><span style="color:#65737e;">
</span><span>}</span><span>
</span><span>
</span><span style="color:#65737e;">// https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDriverId.html</span><span style="color:#65737e;">
</span><span style="color:#65737e;">// maybe handle driver errata</span><span style="color:#65737e;">
</span><span style="color:#b48ead;">switch</span><span>(driver_props.</span><span style="color:#bf616a;">driverID</span><span>)</span><span>
</span><span>{</span><span>
</span><span>  </span><span style="color:#b48ead;">case</span><span> VK_DRIVER_ID_MESA_RADV:</span><span>
</span><span>   </span><span style="color:#65737e;">// ..</span><span style="color:#65737e;">
</span><span>  </span><span style="color:#b48ead;">case</span><span> VK_DRIVER_ID_AMD_OPEN_SOURCE:</span><span>
</span><span>   </span><span style="color:#65737e;">// ..</span><span style="color:#65737e;">
</span><span>}</span><span>
</span><span>
</span><span style="color:#65737e;">// maybe log the driver name</span><span style="color:#65737e;">
</span><span style="color:#bf616a;">printf</span><span>(&quot;</span><span style="color:#a3be8c;">driver: </span><span style="color:#d08770;">%s</span><span style="color:#96b5b4;">\n</span><span>&quot;, driver_props.</span><span style="color:#bf616a;">driverName</span><span>);</span><span>
</span></code></pre>
<p>Hopefully that demystified a little of the Vulkan API for you. </p>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://hotarubiemu.github.io/cmake-global-build-configuration/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">CMake: Global Build Configuration</span>
                        </a>
                    </span>
                
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2022
 Powered by <a href="https://www.getzola.org/">Zola</a></span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
